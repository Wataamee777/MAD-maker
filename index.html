<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>MAD Frequency MIDI Tool</title>
<script src="https://unpkg.com/@tonejs/midi/build/Midi.js"></script>
<style>
  body { font-family:sans-serif; background:#111; color:#eee; padding:20px }
  button { padding:8px 14px; margin-top:10px }
</style>
</head>
<body>

<h2>MAD 周波数帯 MIDI ツール</h2>

<div>
  音源: <input type="file" id="audioInput" accept="audio/*">
</div>
<div>
  MIDI: <input type="file" id="midiInput" accept=".mid">
</div>

<button id="renderBtn">WAV 書き出し</button>
<br>
<a id="download"></a>

<script>
let audioBuffer = null;
let midiData = null;

const audioInput = document.getElementById("audioInput");
const midiInput  = document.getElementById("midiInput");
const renderBtn  = document.getElementById("renderBtn");
const download   = document.getElementById("download");

/* ===== 周波数計算 ===== */
function midiToFreq(n) {
  return 440 * Math.pow(2, (n - 69) / 12);
}

function noteToBand(midi, width = 0.25) {
  const f = midiToFreq(midi);
  return [f * (1 - width), f * (1 + width)];
}

/* ===== WAV変換 ===== */
function bufferToWav(buffer) {
  const ch = buffer.numberOfChannels;
  const len = buffer.length * ch * 2 + 44;
  const view = new DataView(new ArrayBuffer(len));
  let pos = 0;

  const u16 = v => { view.setUint16(pos,v,true); pos+=2 };
  const u32 = v => { view.setUint32(pos,v,true); pos+=4 };

  u32(0x46464952); u32(len-8); u32(0x45564157);
  u32(0x20746d66); u32(16); u16(1); u16(ch);
  u32(buffer.sampleRate);
  u32(buffer.sampleRate * ch * 2);
  u16(ch * 2); u16(16);
  u32(0x61746164); u32(len - pos - 4);

  for (let i=0;i<buffer.length;i++){
    for (let c=0;c<ch;c++){
      let s = buffer.getChannelData(c)[i];
      s = Math.max(-1,Math.min(1,s));
      view.setInt16(pos, s<0?s*0x8000:s*0x7fff, true);
      pos+=2;
    }
  }
  return new Blob([view], {type:"audio/wav"});
}

/* ===== 読み込み ===== */
audioInput.onchange = async e => {
  const buf = await e.target.files[0].arrayBuffer();
  const ctx = new AudioContext();
  audioBuffer = await ctx.decodeAudioData(buf);
  alert("音源 読み込みOK");
};

midiInput.onchange = async e => {
  const buf = await e.target.files[0].arrayBuffer();
  midiData = new Midi(buf);
  alert("MIDI 読み込みOK");
};

/* ===== 書き出し ===== */
renderBtn.onclick = async () => {
  if (!audioBuffer || !midiData) {
    alert("音源とMIDIを両方入れて");
    return;
  }

  const rate = audioBuffer.sampleRate;
  const duration = midiData.duration + 1;

  const offline = new OfflineAudioContext(
    audioBuffer.numberOfChannels,
    rate * duration,
    rate
  );

  midiData.tracks.forEach(track => {
    track.notes.forEach(note => {
      const src = offline.createBufferSource();
      src.buffer = audioBuffer;

      const [low, high] = noteToBand(note.midi);

      const hp = offline.createBiquadFilter();
      hp.type = "highpass";
      hp.frequency.value = low;

      const lp = offline.createBiquadFilter();
      lp.type = "lowpass";
      lp.frequency.value = high;

      const gain = offline.createGain();
      gain.gain.value = note.velocity;

      src.connect(hp);
      hp.connect(lp);
      lp.connect(gain);
      gain.connect(offline.destination);

      src.start(note.time, 0, 0.06);
    });
  });

  const rendered = await offline.startRendering();
  const wav = bufferToWav(rendered);

  const url = URL.createObjectURL(wav);
  download.href = url;
  download.download = "mad.wav";
  download.textContent = "⬇ WAV ダウンロード";
};
</script>
</body>
</html>
